<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网页中引入javascript方式</title>
      <link href="2020/11069049.html"/>
      <url>2020/11069049.html</url>
      
        <content type="html"><![CDATA[<p>JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。<a id="more"></a></p><h3 id="㈠-使用-lt-script-gt-lt-script-gt"><a href="#㈠-使用-lt-script-gt-lt-script-gt" class="headerlink" title="㈠ 使用&lt;script&gt;...&lt;/script&gt;"></a>㈠ 使用<code>&lt;script&gt;...&lt;/script&gt;</code></h3><p>使用 <code>&lt;script&gt;...&lt;/script&gt;</code> 标签将JavaScript代码嵌入MTML文档中，也是最常用的方法。</p><h4 id="基本语法格式"><a href="#基本语法格式" class="headerlink" title="基本语法格式"></a>基本语法格式</h4><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;......&lt;/script&gt;</code></pre><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var t1,t2,htime,sum=0;    t1=new Date();        document.write(&quot;循环当前时间是：&quot;                       +t1.toLocaleString()+&quot;:&quot;+t1.getMilliseconds()+&quot;&lt;/br&gt;&quot;);        for(var i=1;i&lt;=10000;i++)&#123;            sum+=i;        &#125;    t2=new Date();        document.write(&quot;循环当前时间是：&quot;                       +t2.toLocaleString()+&quot;:&quot;+t2.getMilliseconds()+&quot;&lt;/br&gt;&quot;);        htime = t2.getTime()-t1.getTime();        document.write(&quot;执行10000次循环用时：&quot;+htime+&quot;毫秒&quot;);&lt;/script&gt;</code></pre><h4 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h4><p><strong>1.<code>&lt;script&gt;...&lt;/script&gt;</code>标签位置不固定，可以在<code>&lt;head&gt;...&lt;/head&gt;</code>或者<code>&lt;body&gt;...&lt;/body&gt;</code>中的任何位置</strong></p><p><strong>2.这种方式常用于<code>JavaScript</code>脚本代码较少，并且网站中每个页面使用的<code>JavaScript</code>脚本代码均不同的情况。</strong>  </p><h3 id="㈡链接外部JavaScript文件"><a href="#㈡链接外部JavaScript文件" class="headerlink" title="㈡链接外部JavaScript文件"></a>㈡链接外部JavaScript文件</h3><p>外部JavaScript文件是将JavaScript写入一个外部文件中，以<code>.js</code>为文件后缀名，然后通过<code>&lt;script&gt;</code>标签的src属性嵌入到HTML文档中</p><h4 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h4><pre><code>&lt;head&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./1.css&quot;&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;./1.js&quot;&gt;&lt;/script&gt;  //外链式 文件名：1.js&lt;/head&gt;</code></pre><h4 id="注-1"><a href="#注-1" class="headerlink" title="注:"></a>注:</h4><p><strong>1.外部文件中不能包含<code>&lt;script&gt;</code>标签</strong></p><h3 id="㈢JavaScript伪URL引入"><a href="#㈢JavaScript伪URL引入" class="headerlink" title="㈢JavaScript伪URL引入"></a>㈢JavaScript伪URL引入</h3><p><strong>格式：</strong>JavaScript：JavaScript脚本代码</p><h4 id="举例说明-2"><a href="#举例说明-2" class="headerlink" title="举例说明"></a>举例说明</h4><pre><code> &lt;p&gt;伪URL地址引入JavaScript脚本代码实例：&lt;/p&gt; &lt;form name=&quot;MyForm&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;MyText&quot; value=&quot;鼠标单击&quot; onclick=&quot;javascript:alert(&#39;鼠标已单击文本框！&#39;)&quot; &lt;/form&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell-for语句</title>
      <link href="2020/110338103.html"/>
      <url>2020/110338103.html</url>
      
        <content type="html"><![CDATA[<h3 id="列表循环"><a href="#列表循环" class="headerlink" title="列表循环"></a>列表循环</h3><h4 id="列表for循环：用于将一组命令执行知的次数"><a href="#列表for循环：用于将一组命令执行知的次数" class="headerlink" title="列表for循环：用于将一组命令执行知的次数"></a>列表for循环：用于将一组命令执行知的次数</h4><h4 id="基本语法格式"><a href="#基本语法格式" class="headerlink" title="基本语法格式"></a>基本语法格式</h4><p>powershell    </p><pre><code>for variable in &#123;list&#125;         do</code></pre><a id="more"></a><pre><code>         command          command         …    done</code></pre><p>或者</p><pre><code>for variable in a b c      do        command        command</code></pre><p><strong>举例说明</strong></p><p>  powershell</p><pre><code> for var in &#123;1..10&#125;;do echo $var;done  for var in 1 2 3 4 5;do echo $var;done     for var in `seq 10`;do echo $var;done    for var in $(seq 10);do echo $var;done   for var in &#123;0..10..2&#125;;do echo $var;done   for var in &#123;2..10..2&#125;;do echo $var;done   for var in &#123;10..1&#125;;do echo $var;done for var in &#123;10..1..-2&#125;;do echo $var;done    for var in `seq 10 -2 1`;do echo $var;done   </code></pre><h3 id="㈡-不带列表循环"><a href="#㈡-不带列表循环" class="headerlink" title="㈡ 不带列表循环"></a>㈡ 不带列表循环</h3><h4 id="不带列表的for循环执行时由用户指定参数和参数的个数"><a href="#不带列表的for循环执行时由用户指定参数和参数的个数" class="headerlink" title="不带列表的for循环执行时由用户指定参数和参数的个数"></a>不带列表的for循环执行时由用户指定参数和参数的个数</h4><h4 id="基本语法格式-1"><a href="#基本语法格式-1" class="headerlink" title="基本语法格式"></a>基本语法格式</h4><p>powershell  </p><pre><code>for variable  do      command     command    …done</code></pre><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>powershell<br>    #!/bin/bash<br>    for var<br>    do<br>        echo $var<br>    done</p><p>echo “脚本后面有$#个参数”</p><h3 id="㈢-类C风格的for循环"><a href="#㈢-类C风格的for循环" class="headerlink" title="㈢ 类C风格的for循环"></a>㈢ 类C风格的for循环</h3><h4 id="基本语法结构"><a href="#基本语法结构" class="headerlink" title="基本语法结构"></a>基本语法结构</h4><p>powershell   </p><pre><code>for(( expr1;expr2;expr3 ))    do        command        command        …    donefor (( i=1;i&lt;=5;i++))    do      echo $idone</code></pre><p>expr1：定义变量并赋初值<br>expr2：决定是否进行循环（条件）<br>expr3：决定循环变量如何改变，决定循环什么时候退出</p><h4 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h4><p>powershell  </p><pre><code># for ((i=1;i&lt;=5;i++));do echo $i;done    # for ((i=1;i&lt;=10;i+=2));do echo $i;done  # for ((i=2;i&lt;=10;i+=2));do echo $i;done  </code></pre><h2 id="2-应用案例"><a href="#2-应用案例" class="headerlink" title="2. 应用案例"></a>2. 应用案例</h2><h3 id="㈠-脚本计算1-100奇数和"><a href="#㈠-脚本计算1-100奇数和" class="headerlink" title="㈠ 脚本计算1-100奇数和"></a>㈠ 脚本计算1-100奇数和</h3><h4 id="①-思路"><a href="#①-思路" class="headerlink" title="① 思路"></a>① 思路</h4><ol><li>定义一个变量来保存奇数的和   ==sum===0</li><li>找出1-100的奇数，保存到另一个变量里 i 遍历出来的奇数</li><li>从1-100中找出奇数后，再相加，然后将和赋值给变量  循环变量  for</li><li>遍历完毕后，将sum的值打印出来<h4 id="②-落地实现（条条大路通罗马）"><a href="#②-落地实现（条条大路通罗马）" class="headerlink" title="② 落地实现（条条大路通罗马）"></a>② 落地实现（条条大路通罗马）</h4></li></ol><p>powershell<br><code>#!/bin/env bash</code><br>计算1-100的奇数和<br>定义变量来保存奇数和  </p><pre><code>sum=0for &amp;emsp; &amp;emsp;循环遍历1-100的奇数，并且相加，把结果重新赋值给sumfor i in &#123;1..100..2&#125;do    let sum=$sum+$idone  &amp;emsp; &amp;emsp;打印所有奇数的和echo &quot;1-100的奇数和是:$sum&quot;  </code></pre><p><strong>方法1：</strong></p><pre><code>#!/bin/bashsum=0for i in &#123;1..100..2&#125;do    sum=$[$i+$sum]doneecho &quot;1-100的奇数和为:$sum&quot;</code></pre><p><strong>方法2：</strong></p><pre><code>#!/bin/bashsum=0for ((i=1;i&lt;=100;i+=2))do    let sum=$i+$sumdoneecho &quot;1-100的奇数和为:$sum&quot;</code></pre><p><strong>方法3：</strong></p><pre><code>#!/bin/bashsum=0for ((i=1;i&lt;=100;i++))do    if [ $[$i%2] -ne 0 ];then    let sum=$sum+$i    fi  </code></pre><p>或者   </p><pre><code>test $[$i%2] -ne 0 &amp;&amp; let sum=$sum+$idoneecho &quot;1-100的奇数和为:$sum&quot;</code></pre><p><strong>方法4：</strong>  </p><pre><code>sum=0for ((i=1;i&lt;=100;i++))do    if [ $[$i%2] -eq 0 ];then    continue    else    let sum=$sum+$i    fidoneecho &quot;1-100的奇数和为:$sum&quot;#!/bin/bashsum=0for ((i=1;i&lt;=100;i++))do    test $[$i%2] -eq 0 &amp;&amp; continue || let sum=sum+$idoneecho &quot;1-100的奇数和是:$sum&quot;</code></pre><h4 id="③-循环控制语句"><a href="#③-循环控制语句" class="headerlink" title="③ 循环控制语句"></a>③ 循环控制语句</h4><p><strong>循环体：</strong> do….done之间的内容</p><ul><li>continue：继续；表示循环体内下面的代码不执行，重新开始下一次循环</li><li>break：打断；马上停止执行本次循环，执行循环体后面的代码</li><li>exit：表示直接跳出程序</li></ul><p>shell   </p><pre><code>[root@server ~]# cat for5.sh #!/bin/bashfor i in &#123;1..5&#125;do    test $i -eq 2 &amp;&amp; break || touch /tmp/file$idoneecho hello hahahah</code></pre><h3 id="㈡-判断所输整数是否为质数"><a href="#㈡-判断所输整数是否为质数" class="headerlink" title="㈡ 判断所输整数是否为质数"></a>㈡ 判断所输整数是否为质数</h3><p><strong>质数(素数)：</strong>只能被1和它本身整除的数叫质数。   </p><p>2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</p><h4 id="①-思路-1"><a href="#①-思路-1" class="headerlink" title="① 思路"></a>① 思路</h4><ol><li>让用户输入一个数，保存到一个变量里   <code>read -p &quot;请输入一个正整数:&quot; num</code></li><li>如果能被其他数整除就不是质数——&gt;<code>$num%$i </code>是否等于0    <code>$i=2到​$num-1</code></li><li>如果输入的数是1或者2取模根据上面判断又不符合，所以先排除1和2</li><li>测试序列从2开始，输入的数是4——&gt;得出结果<code>$num</code>不能和<code>$i</code>相等，并且<code>$num</code>不能小于<code>$i</code></li></ol><h4 id="②-落地实现"><a href="#②-落地实现" class="headerlink" title="② 落地实现"></a>② 落地实现</h4><pre><code>powershell#!/bin/env bash#定义变量来保存用户所输入数字read -p &quot;请输入一个正整数字:&quot; number#先排除用户输入的数字1和2[ $number -eq 1 ] &amp;&amp; echo &quot;$number不是质数&quot; &amp;&amp; exit[ $number -eq 2 ] &amp;&amp; echo &quot;$number是质数&quot; &amp;&amp; exit#循环判断用户所输入的数字是否质数for i in `seq 2 $[$number-1]`    do     [ $[$number%$i] -eq 0 ] &amp;&amp; echo &quot;$number不是质数&quot; &amp;&amp; exit    doneecho &quot;$number是质数&quot;</code></pre><p>优化思路：没有必要全部产生2~$[$number-1]序列，只需要产生一半即可。</p><p>更好解决办法：类C风格完美避开了生成序列的坑</p><pre><code>for (( i=2;i&lt;=$[$number-1];i++))do        [ $[$number%$i] -eq 0 ] &amp;&amp; echo &quot;$number不是质数&quot; &amp;&amp; exitdoneecho &quot;$number是质数&quot;</code></pre><h3 id="㈢-批量创建用户"><a href="#㈢-批量创建用户" class="headerlink" title="㈢ 批量创建用户"></a>㈢ 批量创建用户</h3><p><strong>需求：</strong>批量加5个新用户，以u1到u5命名，并统一加一个新组，组名为class,统一改密码为123</p><h4 id="①-思路-2"><a href="#①-思路-2" class="headerlink" title="① 思路"></a>① 思路</h4><ol><li><p>添加用户的命令    <code>useradd -G class</code>  </p></li><li><p>判断class组是否存在  <code>grep -w ^class /etc/group</code> 或者  <code>groupadd class</code></p></li><li><p>根据题意，判断该脚本循环5次来添加用户  <code>for</code>  </p></li><li><p>给用户设置密码，应该放到循环体里面</p><h4 id="②-落地实现-1"><a href="#②-落地实现-1" class="headerlink" title="② 落地实现"></a>② 落地实现</h4></li></ol><p>powershell<br>    #!/bin/env bash<br>    判断class组是否存在<br>    grep -w ^class /etc/group &amp;&gt;/dev/null<br>    test $? -ne 0 &amp;&amp; groupadd class<br>    循环创建用户<br>    for ((i=1;i&lt;=5;i++))<br>    do<br>        useradd -G class u$i<br>        echo 123|passwd –stdin u$i<br>    done<br>    用户创建信息保存日志文件</p><p><strong>方法一：</strong>  </p><pre><code>#!/bin/bashgrep -w class /etc/group &amp;&gt;/dev/null  #判断class组是否存在[ $? -ne 0 ] &amp;&amp; groupadd classfor i in &#123;1..5&#125;  #批量创建5个用户do    useradd -G class u$i    echo 123|passwd --stdin u$idone</code></pre><p><strong>方法二：</strong>  </p><pre><code>#!/bin/bash#判断class组是否存在cut -d: -f1 /etc/group|grep -w class &amp;&gt;/dev/null[ $? -ne 0 ] &amp;&amp; groupadd class#循环增加用户，循环次数5次，for循环,给用户设定密码for ((i=1;i&lt;=5;i++))do    useradd u$i -G class    echo 123|passwd --stdin u$idone</code></pre><p><strong>方法三：</strong></p><pre><code>#!/bin/bashgrep -w class /etc/group &amp;&gt;/dev/nulltest $? -ne 0 &amp;&amp; groupadd class    或者  groupadd class &amp;&gt;/dev/nullfor ((i=1;i&lt;=5;i++))douseradd -G class u$i &amp;&amp; echo 123|passwd --stdin u$idone</code></pre><h3 id="（四）判断局域网内主机网络通讯"><a href="#（四）判断局域网内主机网络通讯" class="headerlink" title="（四）判断局域网内主机网络通讯"></a>（四）判断局域网内主机网络通讯</h3><p><strong>需求：</strong></p><p>写一个脚本，局域网内，把能ping通的IP和不能ping通的IP分类，并保存到两个文本文件里<br>以10.1.1.1~10.1.1.10为例</p><p>powershell<br>10.1.1.1~10.1.1.254</p><pre><code>#!/bin/bash定义变量ip=10.1.1#循环去ping主机的IPfor ((i=1;i&lt;=10;i++))do    ping -c1 $ip.$i &amp;&gt;/dev/null    if [ $? -eq 0 ];then        echo &quot;$ip.$i is ok&quot; &gt;&gt; /tmp/ip_up.txt    else        echo &quot;$ip.$i is down&quot; &gt;&gt; /tmp/ip_down.txt    fi  </code></pre><p>或者  </p><pre><code>[ $? -eq 0 ] &amp;&amp; echo &quot;$ip.$i is ok&quot; &gt;&gt; /tmp/ip_up.txt || echo &quot;$ip.$i is down&quot; &gt;&gt; /tmp/ip_down.txt    done</code></pre><p>[root@server shell03]# time ./ping.sh         </p><p>real    0m24.129s<br>user    0m0.006s<br>sys     0m0.005s</p><p><strong>延伸扩展：shell脚本并发</strong></p><p>powershell<br>并行执行：<br>{程序}&amp;表示将程序放到后台并行执行，如果需要等待程序执行完毕再进行下面内容，需要加wait</p><pre><code>#!/bin/bash#定义变量ip=10.1.1#循环去ping主机的IPfor ((i=1;i&lt;=10;i++))do&#123;        ping -c1 $ip.$i &amp;&gt;/dev/null        if [ $? -eq 0 ];then                echo &quot;$ip.$i is ok&quot; &gt;&gt; /tmp/ip_up.txt        else                echo &quot;$ip.$i is down&quot; &gt;&gt; /tmp/ip_down.txt        fi&#125;&amp;donewaitecho &quot;ip is ok....&quot;[root@server ~]# time ./ping.sh ip is ok...real    0m3.091suser    0m0.001ssys     0m0.008s</code></pre><h3 id="㈢-判断闰年"><a href="#㈢-判断闰年" class="headerlink" title="㈢ 判断闰年"></a>㈢ 判断闰年</h3><p><strong>需求3：</strong></p><p>输入一个年份，判断是否是润年（能被4整除但不能被100整除，或能被400整除的年份即为闰年）</p><p>powershell  </p><pre><code>#!/bin/bashread -p &quot;Please input year:(2017)&quot; yearif [ $[$year%4] -eq 0 -a $[$year%100] -ne 0 ];then    echo &quot;$year is leap year&quot;elif [ $[$year%400] -eq 0 ];then    echo &quot;$year is leap year&quot;else    echo &quot;$year is not leap year&quot;fi</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>node重新安装依赖模块</title>
      <link href="2020/103126509.html"/>
      <url>2020/103126509.html</url>
      
        <content type="html"><![CDATA[<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。<a id="more"></a></p><h3 id="windows操作系统"><a href="#windows操作系统" class="headerlink" title="windows操作系统"></a>windows操作系统</h3><p>npm install -g rimraf<br> rimraf node_modules<br><code>rimraf package-lock.json</code></p><h3 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><p><code>rm -rf node_modules</code><br><code>rm package-lock.json</code></p><h3 id="2-清除缓存（非必须）下方代码不分操作系统"><a href="#2-清除缓存（非必须）下方代码不分操作系统" class="headerlink" title="2.清除缓存（非必须）下方代码不分操作系统"></a>2.清除缓存（非必须）下方代码不分操作系统</h3><p><code>npm cache clear --force</code></p><h3 id="3-重新安装依赖包，安装完成会自动生成package-lock-json"><a href="#3-重新安装依赖包，安装完成会自动生成package-lock-json" class="headerlink" title="3.重新安装依赖包，安装完成会自动生成package-lock.json"></a>3.重新安装依赖包，安装完成会自动生成package-lock.json</h3><p><code>npm config install -g cnpm --registry=https://registry.npm.taobao.org</code></p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-yum配置</title>
      <link href="2020/102961227.html"/>
      <url>2020/102961227.html</url>
      
        <content type="html"><![CDATA[<p>yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器，类似Windows下软件管家。<a id="more"></a></p><h3 id="yum源分类"><a href="#yum源分类" class="headerlink" title="yum源分类"></a>yum源分类</h3><p> <strong>① 本地yum源</strong>  </p><p>所谓本地yum源是指yum仓库在本地，一般是本地系统光盘或镜像文件。</p><p><strong>② 网络yum源</strong>  </p><p>所谓网络yum源是指yum仓库在远程（不在本地），需要联网才能安装。国内较知名的网络源（aliyun源，163源，sohu源，知名大学开源镜像等）国外较知名的网络源（centos源、redhat源、红帽扩展epel源等）特定软件相关的网络源（Nginx、MySQL、Zabbix等）</p><h4 id="本地yum源配置"><a href="#本地yum源配置" class="headerlink" title="本地yum源配置"></a>本地yum源配置</h4><p><strong>说明：以下操作系统以Redhat7.0为例，其他Linux系统类似。</strong></p><p>① 通过配置文件指定yum仓库   </p><pre><code>root@Heima ~]# cd /etc/yum.repos.d/[root@Heima yum.repos.d]# rm -f ./*   在该目录下创建以.repo结尾的文件[root@Heima yum.repos.d]# vim local.repo [local]                                  仓库的名字，不要有特殊符号（自定义）name=local yum                          仓库描述,可以不写baseurl=file:///mnt                      指定yum仓库的路径（重要）,file://表示本地仓库 enabled=1                              表示启用该仓库,1表示启用；0表示不启用gpgcheck=0</code></pre><p>② 挂载镜像到本地操作系统  </p><p>手动挂载光盘到指定目录  </p><pre><code>[root@Heima ~]# mount -o ro /dev/sr0 /mnt      开机自动挂载[root@Heima ~]# echo &quot;mount -o ro /dev/sr0 /mnt&quot; &gt;&gt; /etc/rc.local</code></pre><p>或者开机自动挂载</p><pre><code>[root@Heima ~]# echo &quot;/dev/sr0 /mnt iso9660 defaults,ro 0 0&quot; &gt;&gt; /etc/fstab    开机自动挂载 </code></pre><p>注：如果要开机自动挂载，挂载点不存在可以导致系统开不了机</p><h4 id="网络yum源配置"><a href="#网络yum源配置" class="headerlink" title="网络yum源配置"></a>网络yum源配置</h4><p>①保证能上网（上阿里云下载镜像资源）wget <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></p><p>当然也用vim创建文件把镜像粘贴进去（vi /etc/yum.repos.d/CentOS-Base.repo 创建文件）</p><p>②清除yum缓存  </p><pre><code>yum clean all</code></pre><p>生成本地缓存  </p><pre><code>yum makecache</code></pre><p>安装  </p><pre><code>yum install 全部安装yum install package1 安装指定的安装包 package1   </code></pre><h3 id="yum-常用命令"><a href="#yum-常用命令" class="headerlink" title="yum 常用命令"></a>yum 常用命令</h3><p>更新和升级  </p><pre><code>yum update 全部更新yum update package1 更新指定程序包 package1yum check-update 检查可更新的程序yum upgrade package1 升级指定程序包 package1</code></pre><p>查找和显示 </p><pre><code>yum info package1 显示安装包信息 package1yum list 显示所有已经安装和可以安装的程序包yum list package1 显示指定程序包安装情况 package1</code></pre><p>删除程序  </p><pre><code>yum remove package1 删除程序包 package1yum deplist package1 查看程序 package1 依赖情况  </code></pre><p>(5). 清除缓存   </p><pre><code>yum clean packages 清除缓存目录下的软件包yum clean headers 清除缓存目录下的 headersyum clean oldheaders 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的 headers</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git本地版本库</title>
      <link href="2020/102632951.html"/>
      <url>2020/102632951.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git是一个分布式的版本控制系统，它功能强大、操作简单，并且能很好地解决以上问题。目前，熟练地使用Git已经成了一个软件开发从业者必备的技能。<a id="more"></a>同时，其他领域的工作者也可以使用Git进行产品的版本控制。</p><p><strong>安装</strong></p><p> 可以使用源码安装，的具体过程安装请参考Git官网教程或者Github上Git仓库的用户指南。还是建议直接安装。  </p><ul><li>Linux下安装：<br>Fedora下安装<br>  yum install git-core<br>Ubuntu系统<br>  apt-get install git</li></ul><ul><li><p>Mac上安装：<br>在Mac上安装Git有两种方式。可以使用图形化的Git安装工具，网址为图形化Git工具安装地址；另一种是通过MacPorts安装。如果已经装好了MacPorts，请用下面的命令安装Git：<br>  sudo port install git-core +svn +doc +bash_completion +gitweb</p></li><li><p>Windows下安装：  可以使用msysGit的项目提供的安装包，可以到GitHub官网上’<a href="https://gitforwindows.org/&#39;%EF%BC%8C%E4%B8%8B%E8%BD%BDexe%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6%E5%B9%B6%E8%BF%90%E8%A1%8C%E3%80%82">https://gitforwindows.org/&#39;，下载exe安装文件并运行。</a>  </p></li></ul><p><strong>Git配置</strong><br>由于Git是一个分布式的版本控制系统，所以当利用它进行分工协作时，必须区分不同的机器。这一点可以通过配置机器的名字和邮箱完成。Git初始使用时，也会提示进行配置。配置命令如下：  </p><pre><code>git config --global user.name &quot;Your Name&quot;      //用户名  git config --global user.email &quot;email@example.com&quot;  //邮箱</code></pre><h3 id="1-Git入门之本地版本库"><a href="#1-Git入门之本地版本库" class="headerlink" title="1.Git入门之本地版本库"></a>1.Git入门之本地版本库</h3><p>以下在Linux系统下操作：</p><p><strong>1.1 创建</strong>  </p><p>首先，我们需要创建一个目录，做为我们的本地版本库，然后使用git init命令，将其初始化为一个本地版本库，如下：</p><p>在/home目录下，创建ming目录  </p><pre><code>mkdir /home/ming  </code></pre><p>进入ming目录  </p><pre><code>cd /home/ming    </code></pre><p>将repo初始化为一个本地版本库</p><pre><code>git init  </code></pre><p><strong>1.2 添加修改到暂存区域</strong> </p><p>添加修改，并保存至工作区，需要用到git add命令，git add命令的使用方式如下所示：<br>添加所有修改  </p><pre><code>git add .  </code></pre><p>添加ming.txt文件  </p><pre><code>git add ming.txt  </code></pre><p>需要添加为所有文件至工作区时，使用<code>git add .</code>，如果想添加指定文件，只需要像示例中添加<code>hello.txt</code>一样</p><p><strong>1.3 查看工作区状态</strong>  </p><pre><code>git status</code></pre><p><strong>1.4 撤销修改</strong></p><pre><code>git checkout helloGit.txt   </code></pre><p>这样可以把已经添加到本地的<code>helloGit.txt</code>从暂存区中移除。您可以自己到命令行中，去</p><p><strong>1.5提交修改到本地仓库</strong><br>提交修改到本地仓库，使用命令<code>git commit</code>，其使用方式如下所示：</p><pre><code>git commit -m &quot;示例提交&quot;   </code></pre><p><code>-m</code>参数后面跟的是本次提交的具体内容，用来说明你这次的提交，主要是做了些修改，这个说明内容是必须的。  </p><p><strong>注：</strong> 在执行完git commit命令之后，会得到以下以下的返回结果：</p><pre><code>[master（根提交） 37302ce] 添加helloGit.txt   1 file changed, 0 insertions(+), 0 deletions(-)   create mode 100644 helloGit.txt  </code></pre><p>其中：</p><ul><li>“添加helloGit.txt”为“-m”的参数，即执行的命令为git commit -m “添加helloGit.txt”；</li><li>“1 file changed, 0 insertions(+), 0 deletions(-)” 提示介入信息；</li><li>“37302ce”这个字符串则是本次提交的Id，commit Id唯一对应一次提交。  </li></ul><p> 引用/转载自【<a href="http://61.188.205.37:8081/%E3%80%91">http://61.188.205.37:8081/】</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GIT远程版本库</title>
      <link href="2020/102626680.html"/>
      <url>2020/102626680.html</url>
      
        <content type="html"><![CDATA[<p>git的一大特点就是，能为不同的系统下的开发者提供一个合作开发平台。而团队如果要基于Git进行协同开发，就必须依赖远程版本库<a id="more"></a>。远程版本库允许，我们将本地版本库保存在远端服务器，而且，不同的开发者也是基于远程版本库进行协同开发。因此，远程版本库的各种操作，在Git使用中中间</p><h3 id="1-Git添加远程版本库"><a href="#1-Git添加远程版本库" class="headerlink" title="1.Git添加远程版本库"></a>1.Git添加远程版本库</h3><p>以下在Linux系统下操作：</p><p><strong>1.1 创建</strong>  </p><p>添加远程版本库需要用到的命令是<code>git remote add</code>，其命令格式为</p><pre><code>git remote add “远程仓库名” “远程仓库地址” </code></pre><p>使用示例如下：</p><pre><code>git remote add origin https://sample.git  </code></pre><p>这样就将<code>https://sample.git</code>添加为远程仓库，链接其命名为<code>origin</code>。</p><p><strong>1.2 clone远程版本库</strong>   </p><p>当你刚进入到一个开发团队中，你要做的第一件事情，可能就是获取一份项目的源代码。如果你的团队使用Git，进行版本控制和代码管理的话，你的leader很可能会给你类似于一个<code>https://sample.git</code>的地址。不要惊慌，这很可能就是你们项目的远程版本库地址，通过它你就可以获取到完整的源代码库。</p><p>克隆操作需要用到的命令是<code>git clone</code>，它的具体用法如下所示：</p><pre><code>git clone https://sample.git</code></pre><p>通过这样的操作，可以将远程版本库复制到本地了，而且会替换克隆到<code>sample</code>文件夹下（对应到远程版本库地址中指定的<code>sample</code>）。同时，你也可以根据需要，指定克隆到其他目录下，其命令格式为： </p><pre><code>git clone xxx.git &quot;指定目录&quot;</code></pre><p>这样就能将代码都复制到指定目录下。</p><p><strong>1.3 推送本地内容到远程仓库</strong>  </p><p>在团队开发中一个很容易改变，很普通的行为，就是将你的修改推送到远程仓库，刹车于测试或者和团队中其他人协作。  </p><pre><code>git push 远程仓库名 本地分支名 远程分支名</code></pre><p>具体的使用方法如下：</p><pre><code>git push origin master master </code></pre><p>这样就将本地分散的内容，推送到远程仓库origin的master分支了。</p><p><strong><code>git push</code>的另外一种用法如下：</strong></p><pre><code>git push -u 远程仓库名 本地分支名 远程分支名 </code></pre><p>-u参数的作用是，建立起本地master分支和远程master分支之间的对应关系，下一次如果再推master分支，就可以忽略远程分支名了，如下所示：</p><p>初次推送  </p><pre><code>git push -u origin master master</code></pre><p>再次推送  </p><pre><code>git push origin master</code></pre><p><strong>1.4 拉取远程分支到本地</strong></p><p>拉取远程仓库的内容到本地，需要使用git pull命令，其命令格式为：</p><pre><code>git pull 远程主机名 远程分支名 本地分支名</code></pre><p>其使用示例如下：</p><p>将远程仓库origin的master分支的内容拉取到本地master分支  </p><pre><code>git pull origin master:master</code></pre><p>但是，在使用过程中，也可能会出现一种情况：远程分隔和本地分支对相同内容进行修改，这会导致将远程分区的修改，合并到本地分支的时候发生冲突。这个时候，可以也可以选择直接强制拉取，使用远程分区的修改，覆盖本地分区的修改。强制拉取需要用到-f参数，语法格式如下：</p><pre><code>git pull 远程主机名 远程分支名 本地分支名 -f  </code></pre><p>具体的使用示例如下：</p><p>将远程仓库origin的master分支的内容拉取到本地master分支  </p><pre><code>git pull origin master:master -f</code></pre><p> 引用/转载自【<a href="http://61.188.205.37:8081/%E3%80%91">http://61.188.205.37:8081/】</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RHEL7下搭建DNS服务器</title>
      <link href="2020/101810765.html"/>
      <url>2020/101810765.html</url>
      
        <content type="html"><![CDATA[<p>DNS（Domain Name System，域名系统）技术应运而生。这是一项用于管理和解析域名与 IP 地址对应关系的技术就是能够接受用户输入的域名或 IP 地址<a id="more"></a> ，然后自动查找与之匹配（或者说具有映射关系）的 IP 地址或域名， 即将域名解析为 IP 地址（正向解析），或将 IP 地址解析为域名（反向解析）。这样一来，我 们只需要在浏览器中输入域名就能打开想要访问的网站了。DNS 域名解析技术的正向解析也是我们最常使用的一种工作模式。默认侦听端口<strong>53</strong>  </p><ul><li><p>正向解析：是指根据域名（主机名）查找到对应的 IP 地址。也 就是说，当用户输入了一个域名后，bind 服务程序会自动进行查找，并将匹配到的 IP 地址返 给用户。这也是最常用的 DNS 工作模式。  </p></li><li><p>反向简析：是指ip地址到域名的简析工程。</p></li></ul><h3 id="DNS查询模式："><a href="#DNS查询模式：" class="headerlink" title="DNS查询模式："></a>DNS查询模式：</h3><p><strong>1.迭代查询（转寄查询）：</strong>是指DNS 服务器在收到用户发起的请求时，并不直接回复查询结果，而是告 诉另一台 DNS 服务器的地址，用户再向这台 DNS 服务器提交请求，这样依次反复，直到返 回查询结果。  </p><p><strong>2.递归查询：</strong>是指 DNS 服务 器在收到用户发起的请求时，必须向用户返回一个准确的查询结果。如果 DNS 服务器本地没 有存储与之对应的信息，则该服务器需要询问其他服务器，并将返回的查询结果提交给用户。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><pre><code>yum install named -y </code></pre><h3 id="2-修改全局置文件"><a href="#2-修改全局置文件" class="headerlink" title="2.修改全局置文件"></a>2.修改全局置文件</h3><p><strong>注：</strong> 修改前先备份配置文件<code>etc /named.conf</code>修改两处 listen-on port 53和allow-query  把花括号里面参数改为any；允许侦听所有主机，然后保存退出。注意格式书写。</p><h3 id="3，修改主配置文件"><a href="#3，修改主配置文件" class="headerlink" title="3，修改主配置文件"></a>3，修改主配置文件</h3><p><code>/etc/named.rfc1912.zones</code> 中添加声明正反向区域和反向简析区域。配置反向区域名字，正反向简析区域文件名。完成后wq保存退出，再对配置文件进行检查，named-checkconf /etc/named.rfc1912.zones</p><h3 id="3，创建正反向区域配置文件："><a href="#3，创建正反向区域配置文件：" class="headerlink" title="3，创建正反向区域配置文件："></a>3，创建正反向区域配置文件：</h3><p>创建正向区域文件，要与named.rfc1912.zones中定义正区域文件名字相同不然无法启用named</p><h3 id="5-编辑正向区域配置文件"><a href="#5-编辑正向区域配置文件" class="headerlink" title="5.编辑正向区域配置文件"></a>5.编辑正向区域配置文件</h3><pre><code>vim /var/named/zlxt.com.zone</code></pre><h3 id="6-编辑反向区域配置文件"><a href="#6-编辑反向区域配置文件" class="headerlink" title="6.编辑反向区域配置文件"></a>6.编辑反向区域配置文件</h3><pre><code>vim /var/named/153.168.192.zone</code></pre><h3 id="6-重启服务器"><a href="#6-重启服务器" class="headerlink" title="6.重启服务器"></a>6.重启服务器</h3><pre><code>systemctl restart named </code></pre><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell-function函数</title>
      <link href="2020/101834908.html"/>
      <url>2020/101834908.html</url>
      
        <content type="html"><![CDATA[<p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p><h2 id="1-什么是函数？"><a href="#1-什么是函数？" class="headerlink" title="1. 什么是函数？"></a>1. 什么是函数？</h2><ul><li><p>shell中允许将<strong>一组命令集合</strong>或<strong>语句</strong>形<a id="more"></a><br>成一段<strong>可用代码</strong>，这些代码块称为shell函数</p></li><li><p>给这段代码起个名字称为函数名，后续可以直接调用该段代码的功能</p></li></ul><h2 id="2-如何定义函数？"><a href="#2-如何定义函数？" class="headerlink" title="2. 如何定义函数？"></a>2. 如何定义函数？</h2><p><strong>方法1：</strong><br>powershell  </p><pre><code>函数名()&#123;  函数体（一堆命令的集合，来实现某个功能）   &#125;</code></pre><p><strong>方法2：</strong></p><pre><code>powershellfunction 函数名()&#123;   函数体（一堆命令的集合，来实现某个功能）   echo hello   echo world&#125;</code></pre><p><strong>函数中return说明:</strong></p><ol><li>return可以结束一个函数。类似于循环控制语句break(结束当前循环，执行循环体后面的代码)。</li><li>return默认返回函数中最后一个命令状态值，也可以给定参数值，范围是0-256之间。</li><li>如果没有return命令，函数将返回最后一个指令的退出状态值。</li></ol><h2 id="3-函数如何调用？"><a href="#3-函数如何调用？" class="headerlink" title="3. 函数如何调用？"></a>3. 函数如何调用？</h2><h3 id="㈠-当前命令行调用"><a href="#㈠-当前命令行调用" class="headerlink" title="㈠ 当前命令行调用"></a>㈠ 当前命令行调用</h3><p>powershell  </p><pre><code>[root@MissHou shell04]# cat fun1.sh #!/bin/bashhello()&#123;echo &quot;hello lilei $1&quot;hostname&#125;menu()&#123;cat &lt;&lt;-EOF1. mysql2. web3. app4. exitEOF&#125;[root@MissHou shell04]# source fun1.sh [root@MissHou shell04]# . fun1.sh [root@MissHou shell04]# hello 888hello lilei 888MissHou.itcast.cc[root@MissHou shell04]# menu  1. mysql2. web3. app4. exit</code></pre><h3 id="㈡-定义到用户的环境变量中"><a href="#㈡-定义到用户的环境变量中" class="headerlink" title="㈡ 定义到用户的环境变量中"></a>㈡ 定义到用户的环境变量中</h3><p>powershell  </p><pre><code>[root@MissHou shell05]# vim ~/.bashrc 文件中增加如下内容：hello()&#123;echo &quot;hello lilei $1&quot;hostname&#125;menu()&#123;cat &lt;&lt;-EOF1. mysql2. web3. app4. exitEOF&#125;</code></pre><p>注意：当用户打开bash的时候会读取该文件</p><h3 id="㈢-脚本中调用"><a href="#㈢-脚本中调用" class="headerlink" title="㈢ 脚本中调用"></a>㈢ 脚本中调用</h3><pre><code>powershell#!/bin/bash#打印菜单source ./fun1.shmenu()&#123;cat &lt;&lt;-END    h    显示命令帮助    f    显示磁盘分区    d    显示磁盘挂载    m    查看内存使用    u    查看系统负载    q    退出程序    END&#125;menu        //调用函数</code></pre><h2 id="4-应用案例"><a href="#4-应用案例" class="headerlink" title="4. 应用案例"></a>4. 应用案例</h2><p><strong>具体需求：</strong></p><ol><li>写一个脚本收集用户输入的基本信息(姓名，性别，年龄)，如不输入一直提示输入</li><li>最后根据用户的信息输出相对应的内容</li></ol><p><strong>思路：</strong></p><ol><li><p>交互式定义多个变量来保存用户信息  姓名、性别、年龄</p></li><li><p>如果不输一直提示输入  </p><ul><li>循环直到输入字符串不为空  while  判断输入字符串是否为空</li><li>每个信息都必须不能为空，该功能可以定义为一个函数，方便下面脚本调用</li></ul></li><li><p>根据用户输入信息做出匹配判断</p></li></ol><p><strong>代码实现：</strong></p><pre><code>powershell#!/bin/bash#该函数实现用户如果不输入内容则一直循环直到用户输入为止，并且将用户输入的内容打印出来input_fun()&#123;  input_var=&quot;&quot;  output_var=$1  while [ -z $input_var ]    do    read -p &quot;$output_var&quot; input_var    done    echo $input_var&#125;input_fun 请输入你的姓名:</code></pre><p>或者<br>    #!/bin/bash<br>    fun()<br>    {<br>        read -p “$1” var<br>        if [ -z $var ];then<br>            fun $1<br>        else<br>            echo $var<br>        fi<br>    }</p><pre><code>#调用函数并且获取用户的姓名、性别、年龄分别赋值给name、sex、age变量name=$(input_fun 请输入你的姓名:)sex=$(input_fun 请输入你的性别:)age=$(input_fun 请输入你的年龄:)#根据用户输入的性别进行匹配判断case $sex in            man)            if [ $age -gt 18 -a $age -le 35 ];then                echo &quot;中年大叔你油腻了吗？加油&quot;            elif [ $age -gt 35 ];then                echo &quot;保温杯里泡枸杞&quot;            else                echo &quot;年轻有为。。。&quot;            fi            ;;            woman)            xxx            ;;            *)            xxx            ;;esac</code></pre><p><strong>扩展延伸：</strong><br>powershell  </p><pre><code>描述以下代码含义：    :()&#123;   :|:&amp;&#125;:</code></pre><h1 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h1><h2 id="1-任务背景"><a href="#1-任务背景" class="headerlink" title="1. 任务背景"></a>1. 任务背景</h2><p>现有的跳板机虽然实现了统一入口来访问生产服务器，yunwei用户权限太大可以操作跳板机上的所有目录文件，存在数据被误删的安全隐患，所以希望你做一些安全策略来保证跳板机的正常使用。</p><h2 id="2-具体要求"><a href="#2-具体要求" class="headerlink" title="2. 具体要求"></a>2. 具体要求</h2><ol><li>只允许yunwei用户通过跳板机远程连接后台的应用服务器做一些维护操作</li><li>公司运维人员远程通过yunwei用户连接跳板机时，跳出以下菜单供选择：</li></ol><p>powershell</p><pre><code>欢迎使用Jumper-server，请选择你要操作的主机：1. DB1-Master2. DB2-Slave3. Web14. Web2h. helpq. exit</code></pre><ol start="3"><li>当用户选择相应主机后，直接<strong>免密码登录</strong>成功</li><li>如果用户不输入一直提示用户输入，直到用户选择退出</li></ol><h2 id="3-综合分析"><a href="#3-综合分析" class="headerlink" title="3. 综合分析"></a>3. 综合分析</h2><ol><li>将脚本放到yunwei用户家目录里的.bashrc文件里（/shell05/jumper-server.sh）</li><li>将菜单定义为一个函数[打印菜单]，方便后面调用</li><li>用case语句来实现用户的选择【交互式定义变量】</li><li>当用户选择了某一台服务器后，进一步询问用户需要做的事情  case…esac  交互式定义变量</li><li>使用循环来实现用户不选择一直让其选择</li><li>限制用户退出后直接关闭终端  exit </li></ol><h2 id="4-落地实现"><a href="#4-落地实现" class="headerlink" title="4. 落地实现"></a>4. 落地实现</h2><pre><code>powershell#!/bin/bash# jumper-server# 定义菜单打印功能的函数menu()&#123;cat &lt;&lt;-EOF欢迎使用Jumper-server，请选择你要操作的主机：1. DB1-Master2. DB2-Slave3. Web14. Web2h. helpq. exit    EOF&#125;# 屏蔽以下信号trap &#39;&#39; 1 2 3 19# 调用函数来打印菜单menu#循环等待用户选择while truedo菜单选择，case...esac语句 read -p &quot;请选择你要访问的主机:&quot; hostcase $host in    1)    ssh root@10.1.1.1    ;;    2)    ssh root@10.1.1.2    ;;    3)    ssh root@10.1.1.3    ;;    h)    clear;menu    ;;    q)    exit    ;;esacdone将脚本放到yunwei用户家目录里的.bashrc里执行：bash ~/jumper-server.shexit</code></pre><p><strong>进一步完善需求</strong></p><p>为了进一步增强跳板机的安全性，工作人员通过跳板机访问生产环境，但是不能在跳板机上停留。</p><pre><code>powershell#!/bin/bash#公钥推送成功trap &#39;&#39; 1 2 3 19#打印菜单用户选择menu()&#123;cat &lt;&lt;-EOF欢迎使用Jumper-server，请选择你要操作的主机：1. DB1-Master2. DB2-Slave3. Web14. Web2h. helpq. exitEOF&#125;</code></pre><p>调用函数来打印菜单<br>    menu<br>    while true<br>    do<br>    read -p “请输入你要选择的主机[h for help]：” host</p><pre><code>#通过case语句来匹配用户所输入的主机case $host in    1|DB1)    ssh root@10.1.1.1    ;;    2|DB2)    ssh root@10.1.1.2    ;;    3|web1)    ssh root@10.1.1.250    ;;    h|help)    clear;menu    ;;    q|quit)    exit    ;;esacdone</code></pre><p>自己完善功能：</p><ol><li>用户选择主机后，需要事先推送公钥；如何判断公钥是否已推</li><li>比如选择web1时，再次提示需要做的操作，比如：<br>clean log<br>重启服务<br>kill某个进程</li></ol><p><strong>回顾信号：</strong></p><pre><code>powershell1) SIGHUP             重新加载配置    2) SIGINT            键盘中断^C3) SIGQUIT          键盘退出9) SIGKILL             强制终止15) SIGTERM            终止（正常结束），缺省信号18) SIGCONT               继续19) SIGSTOP               停止20) SIGTSTP         暂停^Z</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-samba文件共享</title>
      <link href="2020/101720280.html"/>
      <url>2020/101720280.html</url>
      
        <content type="html"><![CDATA[<p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议<a id="more"></a></p><h3 id="1-安装samb"><a href="#1-安装samb" class="headerlink" title="1.安装samb"></a>1.安装samb</h3><pre><code>yum install samba -y</code></pre><h3 id="2-启动samba服务"><a href="#2-启动samba服务" class="headerlink" title="2.启动samba服务"></a>2.启动samba服务</h3><pre><code>systemctl stare smb</code></pre><h3 id="3-添加samba用户命令格式如下："><a href="#3-添加samba用户命令格式如下：" class="headerlink" title="3.添加samba用户命令格式如下："></a>3.添加samba用户命令格式如下：</h3><pre><code>-a        为samba添加用户-d        禁用用户-e          启用用户-x          删除 Samba 账户</code></pre><p><strong>注</strong><br>（1）如果创建用户失败首先考虑，创建用户是否为本地用户。</p><p>（2）输入<code>sambpasswd -a 用户</code>终端提示为找到命令。需要安装<code>samab-client</code></p><h3 id="5-创建共享文件。修改samba配置文件。"><a href="#5-创建共享文件。修改samba配置文件。" class="headerlink" title="5.创建共享文件。修改samba配置文件。"></a>5.创建共享文件。修改samba配置文件。</h3><p>添加共享名，共享路径，匿名访问，访问用户组，目录是否只读，过滤主机，目录是否可见等。</p><h3 id="6-设置SELinux-：-getenforce-查看状态"><a href="#6-设置SELinux-：-getenforce-查看状态" class="headerlink" title="6.设置SELinux ： getenforce 查看状态"></a>6.设置SELinux ： getenforce 查看状态</h3><h3 id="7-设置防火墙策略"><a href="#7-设置防火墙策略" class="headerlink" title="7.设置防火墙策略"></a>7.设置防火墙策略</h3><h3 id="8-重启samba服务"><a href="#8-重启samba服务" class="headerlink" title="8.重启samba服务"></a>8.重启samba服务</h3><h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h3><p>本地windows输入：\ 内一台主机IP 即可 如:\192.168.137.10 回车即可<br>如果在在Linux则输入: </p><p>Smbclient -L 目标IP地址或主机名 -U 登录用户名%密码<br>smbclient   //目标IP地址或主机名/共享目录 -U 用户名%密码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell-case语句</title>
      <link href="2020/101664138.html"/>
      <url>2020/101664138.html</url>
      
        <content type="html"><![CDATA[<p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令<a id="more"></a></p><h3 id="1-语法结构"><a href="#1-语法结构" class="headerlink" title="1. 语法结构"></a>1. 语法结构</h3><p>powershell<br>说明：pattern表示需要匹配的模式</p><pre><code>case var in             定义变量;var代表是变量名pattern 1)              模式1;用 | 分割多个模式，相当于or    command1            需要执行的语句    ;;                  两个分号代表命令结束pattern 2)    command2    ;;pattern 3)    command3    ;;          *)              default，不满足以上模式，默认执行*)下面的语句    command4    ;;esac                            esac表示case语句结束</code></pre><h3 id="2-应用案例"><a href="#2-应用案例" class="headerlink" title="2. 应用案例"></a>2. 应用案例</h3><h4 id="㈠-脚本传不同值做不同事"><a href="#㈠-脚本传不同值做不同事" class="headerlink" title="㈠ 脚本传不同值做不同事"></a>㈠ 脚本传不同值做不同事</h4><p>具体需求：当给程序传入start、stop、restart三个不同参数时分别执行相应命令</p><p>powershell  </p><pre><code>#!/bin/env bashcase $1 in        start|S)        service apache start &amp;&gt;/dev/null &amp;&amp; echo &quot;apache 启动成功&quot;        ;;        stop|T)        service apache stop &amp;&gt;/dev/null &amp;&amp; echo &quot;apache 停止成功&quot;        ;;        restart|R)        service apache restart &amp;&gt;/dev/null &amp;&amp; echo &quot;apache 重启完毕&quot;        ;;        *)        echo &quot;请输入要做的事情...&quot;        ;;esac</code></pre><h3 id="㈡-根据用户需求选择做事"><a href="#㈡-根据用户需求选择做事" class="headerlink" title="㈡ 根据用户需求选择做事"></a>㈡ 根据用户需求选择做事</h3><p><strong>具体需求：</strong></p><p>脚本提示让用户输入需要管理的服务名，然后提示用户需要对服务做什么操作，如启动，关闭等操作</p><pre><code>powershell#!/bin/env bashread -p &quot;请输入你要管理的服务名称(vsftpd):&quot; servicecase $service in        vsftpd|ftp)        read -p &quot;请选择你需要做的事情(restart|stop):&quot; action        case $action in                stop|S)                service vsftpd stop &amp;&gt;/dev/null &amp;&amp; echo &quot;该$serivce服务已经停止成功&quot;                ;;                start)                service vsftpd start &amp;&gt;/dev/null &amp;&amp; echo &quot;该$serivce服务已经成功启动&quot;                ;;        esac        ;;        httpd|apache)        echo &quot;apache hello world&quot;        ;;        *)        echo &quot;请输入你要管理的服务名称(vsftpd)&quot;        ;;esac</code></pre><h3 id="㈢-菜单提示让用户选择需要做的事"><a href="#㈢-菜单提示让用户选择需要做的事" class="headerlink" title="㈢ 菜单提示让用户选择需要做的事"></a>㈢ 菜单提示让用户选择需要做的事</h3><p><strong>具体需求：</strong></p><p>模拟一个多任务维护界面;当执行程序时先显示总菜单，然后进行选择后做相应维护监控操作</p><p>powershell  </p><pre><code>**********请选择*********h    显示命令帮助f    显示磁盘分区d    显示磁盘挂载m    查看内存使用u    查看系统负载q    退出程序*************************</code></pre><p><strong>思路：</strong></p><ol><li>菜单打印出来</li><li>交互式让用户输入操作编号，然后做出相应处理</li></ol><p><strong>落地实现：</strong></p><ol><li><p>菜单打印(分解动作)<br>powershell  </p><pre><code> !/bin/env bash cat &lt;&lt;-EOF h    显示命令帮助 f    显示磁盘分区 d    显示磁盘挂载 m    查看内存使用 u    查看系统负载     q    退出程序     EOF</code></pre></li><li><p>最终实现  </p></li></ol><pre><code>    !/bin/bash    打印菜单    cat &lt;&lt;-EOF    h    显示命令帮助    f    显示磁盘分区    d    显示磁盘挂载    m    查看内存使用        u    查看系统负载    q    退出程序    EOF</code></pre><p><strong>让用户输入需要的操作</strong>   </p><pre><code>while truedo read -p &quot;请输入需要操作的选项[f|d]:&quot; var1case $var1 in    h)    cat &lt;&lt;-EOF        h       显示命令帮助        f       显示磁盘分区        d       显示磁盘挂载        m       查看内存使用        u       查看系统负载        q       退出程序    EOF    ;;    f)    fdisk -l    ;;    d)    df -h    ;;    m)    free -m    ;;    u)    uptime    ;;    q)    exit    ;;esacdone</code></pre><p><strong>打印菜单</strong></p><pre><code>#!/bin/bashmenu()&#123;cat &lt;&lt;-END    h    显示命令帮助    f    显示磁盘分区    d    显示磁盘挂载    m    查看内存使用    u    查看系统负载    q    退出程序    END&#125;menuwhile truedoread -p &quot;请输入你的操作[h for help]:&quot; var1case $var1 in    h)    menu    ;;    f)    read -p &quot;请输入你要查看的设备名字[/dev/sdb]:&quot; var2    case $var2 in        /dev/sda)        fdisk -l /dev/sda        ;;        /dev/sdb)        fdisk -l /dev/sdb        ;;    esac    ;;    d)    lsblk    ;;    m)    free -m    ;;    u)    uptime    ;;    q)    exit    ;;esacdone</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RHEL7环境修改root密码</title>
      <link href="2020/101117233.html"/>
      <url>2020/101117233.html</url>
      
        <content type="html"><![CDATA[<p>忘记root密码这个问题出现的几率是很高的，不过，在linux下解决这个问题也很简单，只需重启linux系统，然后引导进入linux的单用户模式<a id="more"></a><br>（init1），由于单用户模式是不需要输入登录密码的，因此，可以直接登录系统，修改root密码即可解决问题。</p><h3 id="1、进入GRUB页面，选择相应的内核，按下’e’键；-备注：第一行为内核；第二行为援救模式"><a href="#1、进入GRUB页面，选择相应的内核，按下’e’键；-备注：第一行为内核；第二行为援救模式" class="headerlink" title="1、进入GRUB页面，选择相应的内核，按下’e’键；(备注：第一行为内核；第二行为援救模式)"></a>1、进入GRUB页面，选择相应的内核，按下’e’键；(备注：第一行为内核；第二行为援救模式)</h3><h3 id="2、进入内核修改信息界面，找到Linux16这一行；"><a href="#2、进入内核修改信息界面，找到Linux16这一行；" class="headerlink" title="2、进入内核修改信息界面，找到Linux16这一行；"></a>2、进入内核修改信息界面，找到Linux16这一行；</h3><p>在这一行的末尾加上init=/bin/sh</p><p>按下’Ctrl + x’进入单用户模式</p><h3 id="3、进入单用户后，重新挂载根目录，使其可写；"><a href="#3、进入单用户后，重新挂载根目录，使其可写；" class="headerlink" title="3、进入单用户后，重新挂载根目录，使其可写；"></a>3、进入单用户后，重新挂载根目录，使其可写；</h3><p>执行<code>mount -o remount,rw /</code></p><h3 id="4、修改密码-输入两遍"><a href="#4、修改密码-输入两遍" class="headerlink" title="4、修改密码(输入两遍)"></a>4、修改密码(输入两遍)</h3><h3 id="5、当selinux防火墙启动时，修改密码后要创建文件touch-autorelabel"><a href="#5、当selinux防火墙启动时，修改密码后要创建文件touch-autorelabel" class="headerlink" title="5、当selinux防火墙启动时，修改密码后要创建文件touch /.autorelabel"></a>5、当selinux防火墙启动时，修改密码后要创建文件touch /.autorelabel</h3><h3 id="6、重启系统"><a href="#6、重启系统" class="headerlink" title="6、重启系统"></a>6、重启系统</h3><p>至此，密码修改完成</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell变量定义</title>
      <link href="2020/101045956.html"/>
      <url>2020/101045956.html</url>
      
        <content type="html"><![CDATA[<p>① Shell的基本语法结构</p><p>  如：变量定义、条件判断、循环语句(for、until、while)、分支语句、函数和数组等； </p><p>  ② 基本正则表达式的运用;</p><p>  ③ 文件处理三剑客：grep、sed、awk工具的使用；</p><a id="more"></a><h1 id="一、SHELL介绍"><a href="#一、SHELL介绍" class="headerlink" title="一、SHELL介绍"></a>一、SHELL介绍</h1><p><strong>前言：</strong></p><p>计算机只能认识（识别）机器语言(0和1)，如（11000000 这种）。但是，我们的程序猿们不能直接去写01这样的代码，所以，要想将程序猿所开发的代码在计算机上运行，就必须找”人”（工具）来翻译成机器语言，这个”人”(工具)就是我们常常所说的<strong>编译器</strong>或者<strong>解释器</strong>。</p><h2 id="1-编程语言分类"><a href="#1-编程语言分类" class="headerlink" title="1. 编程语言分类"></a>1. 编程语言分类</h2><ul><li><strong>编译型语言：</strong></li></ul><p>​    程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++</p><ul><li><strong>解释型语言：</strong></li></ul><p>​    程序不需要编译，程序在运行时由<strong>解释器</strong>翻译成机器语言，每执行一次都要翻译一次。因此效率比较低。比如Python/JavaScript/ Perl /ruby/Shell等都是解释型语言。</p><ul><li><strong>总结</strong></li></ul><p>编译型语言比解释型语言速度较快，但是不如解释型语言跨平台性好。如果做底层开发或者大型应用程序或者操作系开发一般都用编译型语言；如果是一些服务器脚本及一些辅助的接口，对速度要求不高、对各个平台的兼容性有要求的话则一般都用解释型语言。</p><p>##2. shell简介</p><p><strong>总结：</strong></p><ul><li>shell就是人机交互的一个桥梁</li><li>shell的种类</li></ul><p>powershell<br>    [root@MissHou ~]# cat /etc/shells   </p><pre><code>/bin/sh                &amp;emsp;#是bash的一个快捷方式  /bin/bash            &amp;emsp;#bash是大多数Linux默认的shell，包含的功能几乎可以涵盖shell所有的功能  /sbin/nologin        &amp;emsp;#表示非交互，不能登录操作系统  /bin/dash            &amp;emsp;#小巧，高效，功能相比少一些/bin/csh            &amp;emsp;#具有C语言风格的一种shell，具有许多特性，但也有一些缺陷  /bin/tcsh            &amp;emsp;#是csh的增强版，完全兼容csh</code></pre><h2 id="3-shell脚本"><a href="#3-shell脚本" class="headerlink" title="3. shell脚本"></a>3. shell脚本</h2><h3 id="㈠-什么是shell脚本？"><a href="#㈠-什么是shell脚本？" class="headerlink" title="㈠ 什么是shell脚本？"></a>㈠ 什么是shell脚本？</h3><ul><li>一句话概括</li></ul><p>简单来说就是将需要执行的命令保存到文本中，按照顺序执行。它是解释型的，意味着不需要编译。</p><ul><li>准确叙述</li></ul><p><strong>若干命令 + 脚本的基本格式 + 脚本特定语法 + 思想= shell脚本</strong></p><h3 id="㈡-什么时候用到脚本"><a href="#㈡-什么时候用到脚本" class="headerlink" title="㈡ 什么时候用到脚本?"></a>㈡ 什么时候用到脚本?</h3><p><strong>重复化</strong>、复杂化的工作，通过把工作的命令写成脚本，以后仅仅需要执行脚本就能完成这些工作。</p><h3 id="㈢-shell脚本能干啥"><a href="#㈢-shell脚本能干啥" class="headerlink" title="㈢ shell脚本能干啥?"></a>㈢ shell脚本能干啥?</h3><p> ①自动化软件部署             &emsp;LAMP/LNMP/Tomcat…    </p><p> ②自动化管理                 &emsp;系统初始化脚本、批量更改主机密码、推送公钥…</p><p> ③自动化分析处理             &emsp;统计网站访问量</p><p> ④自动化备份                &emsp;数据库备份、日志转储…</p><p> ⑤自动化监控脚本             &emsp;</p><h3 id="㈣-shell脚本的基本写法"><a href="#㈣-shell脚本的基本写法" class="headerlink" title="㈣  shell脚本的基本写法"></a>㈣  shell脚本的基本写法</h3><p>1）<strong>脚本第一行</strong>，魔法字符**#!**指定解释器【必写】</p><p><code>#!/bin/bash</code>  表示以下内容使用bash解释器解析  </p><p><strong>注意：</strong><br>如果直接将解释器路径写死在脚本里，可能在某些系统就会存在找不到解释器的兼容性问题，所以可以使用:<code>#!/bin/env 解释器</code></p><p>2）<strong>脚本第二部分</strong>，注释(#号)说明，对脚本的基本信息进行描述【可选】</p><p>powershell</p><pre><code>#!/bin/env bash 以下内容是对脚本的基本信息的描述 Name: 名字 Desc:描述describe Path:存放路径 Usage:用法 Update:更新时间</code></pre><p>#下面就是脚本的具体内容<br>commands</p><p>3）<strong>脚本第三部分</strong>，脚本要实现的具体代码内容</p><h3 id="（五）-shell脚本的执行方法"><a href="#（五）-shell脚本的执行方法" class="headerlink" title="（五） shell脚本的执行方法"></a>（五） shell脚本的执行方法</h3><ul><li>标准脚本执行方法（建议）  </li></ul><p>powershell  </p><ol><li><p>编写人生第一个shell脚本    </p><p> [root@MissHou shell01]# cat first_shell.sh<br> #!/bin/env bash<br> 以下内容是对脚本的基本信息的描述<br> Name: first_shell.sh<br> Desc: num1<br> Path: /shell01/first_shell.sh<br> Usage:/shell01/first_shell.sh<br> Update:2019-05-05<br> echo “hello world”<br> echo “hello world”<br> echo “hello world”</p></li></ol><ol start="2"><li><p>脚本增加可执行权限  </p><p> [root@MissHou shell01]# chmod +x first_shell.sh</p></li><li><p>标准方式执行脚本  </p><p> [root@MissHou shell01]# pwd<br> /shell01<br> [root@MissHou shell01]# /shell01/first_shell.sh<br>或者<br> [root@MissHou shell01]# ./first_shell.sh</p></li></ol><p>注意：标准执行方式脚本必须要有可执行权限。</p><ul><li>非标准的执行方法（不建议）</li></ul><ol><li>直接在命令行指定解释器执行</li></ol><p>powershell  </p><pre><code>[root@MissHou shell01]# bash first_shell.sh[root@MissHou shell01]# sh first_shell.sh[root@MissHou shell01]# bash -x first_shell.sh+ echo &#39;hello world&#39;hello world+ echo &#39;hello world&#39;hello world+ echo &#39;hello world&#39;hello world</code></pre><p><code>-x</code>:一般用于排错，查看脚本的执行过程<br><code>-n</code>:用来查看脚本的语法是否有问题</p><ol start="2"><li>使用<code>source</code>命令读取脚本文件,执行文件里的代码  </li></ol><p>powershell   </p><pre><code> [root@MissHou shell01]# source first_shell.shhello worldhello worldhello world</code></pre><h1 id="二、变量的定义"><a href="#二、变量的定义" class="headerlink" title="二、变量的定义"></a>二、变量的定义</h1><h2 id="1-变量是什么？"><a href="#1-变量是什么？" class="headerlink" title="1. 变量是什么？"></a>1. 变量是什么？</h2><ul><li>一句话概括：变量是用来临时保存数据的，该数据是可以变化的数据。</li></ul><h2 id="2-什么时候需要定义变量？"><a href="#2-什么时候需要定义变量？" class="headerlink" title="2. 什么时候需要定义变量？"></a>2. 什么时候需要定义变量？</h2><ul><li>如果某个内容需要多次使用，并且在代码中<strong>重复出现</strong>，那么可以用变量代表该内容。这样在修改内容的时候，仅仅需要修改变量的值。</li><li>在代码运作的过程中，可能会把某些命令的执行结果保存起来，后续代码需要使用这些结果，就可以直接使用这个变量。</li></ul><h2 id="3-变量如何定义？"><a href="#3-变量如何定义？" class="headerlink" title="3.变量如何定义？"></a>3.变量如何定义？</h2><p><strong>变量名-变量值</strong></p><ul><li><p>变量名：用来临时保存数据的</p></li><li><p>变量值：就是临时的可变化的数据  </p></li><li><p>  powershell<br>  [root@MissHou ~]# A=hello        定义变量A<br>  [root@MissHou ~]# echo $A        调用变量A，要给钱的，不是人民币是美元”$”<br>  hello<br>  [root@MissHou ~]# echo ${A}        还可以这样调用，不管你的姿势多优雅，总之要给钱<br>  hello<br>  [root@MissHou ~]# A=world        因为是变量所以可以变，移情别恋是常事<br>  [root@MissHou ~]# echo $A        不管你是谁，只要调用就要给钱<br>  world<br>  [root@MissHou ~]# unset A        不跟你玩了，取消变量<br>  [root@MissHou ~]# echo $A        从此，我单身了，你可以给我介绍任何人  </p></li></ul><h2 id="4-变量的定义规则"><a href="#4-变量的定义规则" class="headerlink" title="4. 变量的定义规则"></a>4. 变量的定义规则</h2><p>虽然可以给变量（变量名）赋予任何值；但是，对于==变量名==也是要求的！:unamused:</p><h3 id="㈠-变量名区分大小写"><a href="#㈠-变量名区分大小写" class="headerlink" title="㈠ 变量名区分大小写"></a>㈠ 变量名区分大小写</h3><p>owershell  </p><pre><code>[root@MissHou ~]# A=hello[root@MissHou ~]# a=world[root@MissHou ~]# echo $Ahello[root@MissHou ~]# echo $aworld</code></pre><h3 id="㈡-变量名不能有特殊符号"><a href="#㈡-变量名不能有特殊符号" class="headerlink" title="㈡ 变量名不能有特殊符号"></a>㈡ 变量名不能有特殊符号</h3><p>powershell   </p><pre><code>[root@MissHou ~]# *A=hello-bash: *A=hello: command not found[root@MissHou ~]# ?A=hello-bash: ?A=hello: command not found[root@MissHou ~]# @A=hello-bash: @A=hello: command not found    </code></pre><p>特别说明：对于有空格的字符串给变量赋值时，要用引号引起来    </p><pre><code>[root@MissHou ~]# A=hello world -bash: world: command not found[root@MissHou ~]# A=&quot;hello world&quot;[root@MissHou ~]# A=&#39;hello world&#39;</code></pre><h3 id="㈢-变量名不能以数字开头"><a href="#㈢-变量名不能以数字开头" class="headerlink" title="㈢ 变量名不能以数字开头"></a>㈢ 变量名不能以数字开头</h3><p>powershell  </p><pre><code>[root@MissHou ~]# 1A=hellobash: 1A=hello: command not found[root@MissHou ~]# A1=hello</code></pre><p>注意：不能以数字开头并不代表变量名中不能包含数字呦。</p><h3 id="㈣-等号两边不能有任何空格"><a href="#㈣-等号两边不能有任何空格" class="headerlink" title="㈣ 等号两边不能有任何空格"></a>㈣ 等号两边不能有任何空格</h3><p>powershell  </p><pre><code>[root@MissHou ~]# A =123-bash: A: command not found[root@MissHou ~]# A= 123-bash: 123: command not found[root@MissHou ~]# A = 123-bash: A: command not found[root@MissHou ~]# A=123[root@MissHou ~]# echo $A123</code></pre><h3 id="㈤-变量名尽量做到见名知意"><a href="#㈤-变量名尽量做到见名知意" class="headerlink" title="㈤ 变量名尽量做到见名知意"></a>㈤ 变量名尽量做到见名知意</h3><p>powershell  </p><pre><code>NTP_IP=10.1.1.1DIR=/u01/app1TMP_FILE=/var/log/1.log...</code></pre><p>说明：一般变量名使用大写（小写也可以），不要同一个脚本中变量全是a,b,c等不容易阅读</p><h2 id="5-变量的定义方式有哪些？"><a href="#5-变量的定义方式有哪些？" class="headerlink" title="5. 变量的定义方式有哪些？"></a>5. 变量的定义方式有哪些？</h2><h3 id="㈠-基本方式"><a href="#㈠-基本方式" class="headerlink" title="㈠ 基本方式"></a>㈠ 基本方式</h3><p>直接赋值给一个变量</p><p>powershell  </p><pre><code>[root@MissHou ~]# A=1234567[root@MissHou ~]# echo $A1234567[root@MissHou ~]# echo $&#123;A:2:4&#125;        表示从A变量中第3个字符开始截取，截取4个字符3456</code></pre><p>说明：<br>$变量名 和 ${变量名}的异同<br>相同点：都可以调用变量<br>不同点：${变量名}可以只截取变量的一部分，而$变量名不可以</p><h3 id="㈡-命令执行结果赋值给变量"><a href="#㈡-命令执行结果赋值给变量" class="headerlink" title="㈡ 命令执行结果赋值给变量"></a>㈡ 命令执行结果赋值给变量</h3><p>powershell  </p><pre><code>[root@MissHou ~]# B=`date +%F`[root@MissHou ~]# echo $B2019-04-16[root@MissHou ~]# C=$(uname -r)[root@MissHou ~]# echo $C2.6.32-696.el6.x86_64</code></pre><h3 id="㈢-交互式定义变量-read"><a href="#㈢-交互式定义变量-read" class="headerlink" title="㈢ 交互式定义变量(read)"></a>㈢ 交互式定义变量(read)</h3><p><strong>目的：</strong>让==用户自己==给变量赋值，比较灵活。</p><p><strong>语法：</strong><code>read [选项] 变量名</code></p><p><strong>常见选项：</strong></p><table><thead><tr><th>选项</th><th>释义</th></tr></thead><tbody><tr><td>-p</td><td>定义提示用户的信息</td></tr><tr><td>-n</td><td>定义字符数（限制变量值的长度）</td></tr><tr><td>-s</td><td>不显示（不显示用户输入的内容）</td></tr><tr><td>-t</td><td>定义超时时间，默认单位为秒（限制用户输入变量值的超时时间）</td></tr></tbody></table><p><strong>举例说明：</strong><br>powershell<br>用法1：用户自己定义变量值  </p><pre><code>[root@MissHou ~]# read nameharry[root@MissHou ~]# echo $nameharry[root@MissHou ~]# read -p &quot;Input your name:&quot; nameInput your name:tom[root@MissHou ~]# echo $nametom</code></pre><p>用法2：变量值来自文件  </p><pre><code>[root@MissHou ~]# cat 1.txt 10.1.1.1 255.255.255.0[root@MissHou ~]# read ip mask &lt; 1.txt [root@MissHou ~]# echo $ip10.1.1.1[root@MissHou ~]# echo $mask255.255.255.0</code></pre><h3 id="㈣-定义有类型的变量-declare"><a href="#㈣-定义有类型的变量-declare" class="headerlink" title="㈣ 定义有类型的变量(declare)"></a>㈣ 定义有类型的变量(declare)</h3><p><strong>目的：</strong>给变量做一些限制，固定变量的类型，比如：整型、只读</p><p><strong>用法：</strong><code>declare 选项 变量名=变量值</code></p><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>释义</th><th>举例</th></tr></thead><tbody><tr><td>-i</td><td>将变量看成整数</td><td>declare -i A=123</td></tr><tr><td>-r</td><td>定义只读变量</td><td>declare -r B=hello</td></tr><tr><td>-a</td><td>定义普通数组；查看普通数组</td><td></td></tr><tr><td>-A</td><td>定义关联数组；查看关联数组</td><td></td></tr><tr><td>-x</td><td>将变量通过环境导出</td><td>declare -x AAA=123456 等于 export AAA=123456</td></tr></tbody></table><p><strong>举例说明：</strong></p><pre><code>powershell[root@MissHou ~]# declare -i A=123[root@MissHou ~]# echo $A123[root@MissHou ~]# A=hello[root@MissHou ~]# echo $A0[root@MissHou ~]# declare -r B=hello[root@MissHou ~]# echo $Bhello[root@MissHou ~]# B=world-bash: B: readonly variable[root@MissHou ~]# unset B-bash: unset: B: cannot unset: readonly variable</code></pre><h2 id="6-变量的分类"><a href="#6-变量的分类" class="headerlink" title="6. 变量的分类"></a>6. 变量的分类</h2><h3 id="㈠-本地变量"><a href="#㈠-本地变量" class="headerlink" title="㈠ 本地变量"></a>㈠ 本地变量</h3><ul><li>**==本地变量==**：当前用户自定义的变量。当前进程中有效，其他进程及当前进程的子进程无效。</li></ul><h3 id="㈡-环境变量"><a href="#㈡-环境变量" class="headerlink" title="㈡ 环境变量"></a>㈡ 环境变量</h3><ul><li><p><strong>环境变量</strong>：当前进程有效，并且能够被<strong>子进程</strong>调用。  </p><p> <code>env</code>查看当前用户的环境变量<br> <code>set</code>查询当前用户的所有变量(临时变量与环境变量)<br> <code>export 变量名=变量值</code>    或者  <code>变量名=变量值；export 变量名</code></p></li></ul><p>powershell  </p><pre><code>[root@MissHou ~]# export A=hello  临时将一个本地变量（临时变量）变成环境变量[root@MissHou ~]# env|grep ^AA=hello</code></pre><p>永久生效：<br>    vim /etc/profile 或者 ~/.bashrc<br>    export A=hello<br>    或者<br>    A=hello<br>    export A</p><p>说明：系统中有一个变量PATH，环境变量</p><pre><code>export PATH=/usr/local/mysql/bin:$PATH</code></pre><h3 id="㈢-全局变量"><a href="#㈢-全局变量" class="headerlink" title="㈢ 全局变量"></a>㈢ 全局变量</h3><ul><li><p><strong>全局变量</strong>：全局所有的用户和程序都能调用，且继承，新建的用户也默认能调用.</p></li><li><p><strong>解读相关配置文件</strong></p></li></ul><table><thead><tr><th>文件名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>$HOME/.bashrc</td><td>当前用户的bash信息,用户==登录==时读取</td><td>定义别名、umask、函数等</td></tr><tr><td>$HOME/.bash_profile</td><td>当前用户的环境变量，用户==登录==时读取</td><td></td></tr><tr><td>$HOME/.bash_logout</td><td>当前用户==退出==当前shell时最后读取</td><td>定义用户退出时执行的程序等</td></tr><tr><td>/etc/bashrc</td><td>全局的bash信息，所有用户都生效</td><td></td></tr><tr><td>/etc/profile</td><td>全局环境变量信息</td><td>系统和所有用户都生效</td></tr><tr><td>$HOME/.bash_history</td><td>用户的历史命令</td><td>history -w   保存历史记录         history -c  清空历史记录</td></tr></tbody></table><p><strong>说明：</strong>以上文件修改后，都需要重新==source==让其生效或者退出重新登录。</p><ul><li><strong>用户登录</strong>系统<strong>读取</strong>相关==文件的顺序==<ol><li><code>/etc/profile</code></li><li><code>$HOME/.bash_profile</code></li><li><code>$HOME/.bashrc</code></li><li><code>/etc/bashrc</code></li><li><code>$HOME/.bash_logout</code></li></ol></li></ul><h3 id="㈣-系统变量"><a href="#㈣-系统变量" class="headerlink" title="㈣ 系统变量"></a>㈣ 系统变量</h3><ul><li><strong>系统变量(内置bash中变量)</strong> ： shell本身已经固定好了它的名字和作用.</li></ul><table><thead><tr><th>内置变量</th><th>含义</th></tr></thead><tbody><tr><td>$?</td><td>上一条命令执行后返回的状态；状态值为0表示执行正常，==非0==表示执行异常或错误</td></tr><tr><td>$0</td><td>当前执行的程序或脚本名</td></tr><tr><td>$#</td><td>脚本后面接的参数的个数</td></tr><tr><td>$*</td><td>脚本后面所有参数，参数当成一个整体输出，每一个变量参数之间以空格隔开</td></tr><tr><td>$@</td><td>脚本后面所有参数，参数是独立的，也是全部输出</td></tr><tr><td>$1~$9</td><td>脚本后面的位置参数，$1表示第1个位置参数，依次类推</td></tr><tr><td>${10}~${n}</td><td>扩展位置参数,第10个位置变量必须用{}大括号括起来(2位数字以上扩起来)</td></tr><tr><td>$$</td><td>当前所在进程的进程号，如<code>echo $$</code></td></tr><tr><td>$！</td><td>后台运行的最后一个进程号 (当前终端）</td></tr><tr><td>!$</td><td>调用最后一条命令历史中的参数</td></tr></tbody></table><ul><li>进一步了解位置参数<code>$1~$&#123;n&#125;</code>  </li><li></li></ul><p>powershell  </p><pre><code>~#!/bin/bash~#了解shell内置变量中的位置参数含义  echo &quot;\$0 = $0&quot;echo &quot;\$# = $#&quot;echo &quot;\$* = $*&quot;echo &quot;\$@ = $@&quot;echo &quot;\$1 = $1&quot; echo &quot;\$2 = $2&quot; echo &quot;\$3 = $3&quot; echo &quot;\$11 = $&#123;11&#125;&quot; echo &quot;\$12 = $&#123;12&#125;&quot; </code></pre><ul><li>进一步了解$*和​$@的区别</li></ul><p><code>$*</code>：表示将变量看成一个整体<br><code>$@</code>：表示变量是独立的</p><p>powershell  </p><pre><code>#!/bin/bashfor i in &quot;$@&quot;doecho $idoneecho &quot;======我是分割线=======&quot;for i in &quot;$*&quot;doecho $idone[root@MissHou ~]# bash 3.sh a b cabc======我是分割线=======a b c</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="2020/100115650.html"/>
      <url>2020/100115650.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
